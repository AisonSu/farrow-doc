# Schema Operations & Transformations

> Make your schemas more flexible and reusable 🔄

As your application grows, you'll need to create schema variations based on existing schemas, such as extracting public information from complete user data or making all fields optional. Farrow Schema provides powerful operation tools to meet these needs.

## Type Inference

### TypeOf - Extract Types from Schema

`TypeOf` is the most fundamental and important tool, converting Schema to TypeScript types:

```typescript
import { ObjectType, String, Number, Optional, List, TypeOf } from 'farrow-schema'

class User extends ObjectType {
  id = Number
  name = String
  email = String
  age = Optional(Number)
  tags = List(String)
}

// Extract types
type UserType = TypeOf<typeof User>
// {
//   id: number
//   name: string
//   email: string
//   age?: number
//   tags: string[]
// }

// Use in functions
function processUser(user: UserType) {
  console.log(`Processing ${user.name} (ID: ${user.id})`)
  
  if (user.age) {
    console.log(`Age: ${user.age}`)
  }
  
  if (user.tags.length > 0) {
    console.log(`Tags: ${user.tags.join(', ')}`)
  }
}

// Use in API responses
app.get('/users/<id:int>').use((req) => {
  const user = getUserById(req.params.id)
  
  // user type is automatically inferred as UserType
  return Response.json({ user })
})
```

### Nested Type Extraction

```typescript
class Profile extends ObjectType {
  bio = String
  avatar = Optional(String)
  social = {
    twitter: Optional(String),
    github: Optional(String),
    website: Optional(String)
  }
}

class User extends ObjectType {
  id = Number
  name = String
  email = String
  profile = Profile
}

type UserType = TypeOf<typeof User>
type ProfileType = TypeOf<typeof Profile>

// Can also directly extract from nested structure
type SocialType = UserType['profile']['social']
// {
//   twitter?: string
//   github?: string  
//   website?: string
// }

// Use nested types in functions
function updateUserProfile(userId: number, profile: ProfileType) {
  return updateUser(userId, { profile })
}

function updateUserSocial(userId: number, social: SocialType) {
  const user = getUserById(userId)
  return updateUser(userId, {
    profile: {
      ...user.profile,
      social
    }
  })
}
```

## Field Selection Operations

### pickObject - Select Specific Fields

`pickObject` allows you to select needed fields from ObjectType:

```typescript
import { pickObject } from 'farrow-schema'

class FullUser extends ObjectType {
  id = Number
  name = String
  email = String
  password = String
  phone = Optional(String)
  isAdmin = Boolean
  createdAt = Date
  lastLoginAt = Optional(Date)
  profile = {
    bio: Optional(String),
    avatar: Optional(String)
  }
}

// Create public user info Schema
const PublicUser = pickObject(FullUser, [
  'id', 
  'name', 
  'profile'
])

type PublicUserType = TypeOf<typeof PublicUser>
// {
//   id: number
//   name: string
//   profile: {
//     bio?: string
//     avatar?: string
//   }
// }

// Create user basic info Schema
const UserBasic = pickObject(FullUser, [
  'id',
  'name', 
  'email'
])

// Create admin view Schema
const AdminUser = pickObject(FullUser, [
  'id',
  'name',
  'email', 
  'phone',
  'isAdmin',
  'createdAt',
  'lastLoginAt'
])

// Use in different scenarios
app.get('/users').use(() => {
  const users = getAllUsers()
  
  // Only return public info
  const publicUsers: PublicUserType[] = users.map(user => ({
    id: user.id,
    name: user.name,
    profile: user.profile
  }))
  
  return Response.json({ users: publicUsers })
})

app.get('/admin/users').use((req) => {
  // Require admin permissions
  requireAdmin(req)
  
  const users = getAllUsers()
  
  // Return admin view
  const adminUsers: TypeOf<typeof AdminUser>[] = users.map(user => ({
    id: user.id,
    name: user.name,
    email: user.email,
    phone: user.phone,
    isAdmin: user.isAdmin,
    createdAt: user.createdAt,
    lastLoginAt: user.lastLoginAt
  }))
  
  return Response.json({ users: adminUsers })
})
```

### omitObject - Exclude Specific Fields

`omitObject` is the opposite of `pickObject`, excluding unwanted fields:

```typescript
// Exclude sensitive fields
const SafeUser = omitObject(FullUser, ['password'])

type SafeUserType = TypeOf<typeof SafeUser>
// Contains all fields except password

// Exclude system fields, create user input Schema
const UserInput = omitObject(FullUser, [
  'id',           // ID generated by system
  'createdAt',    // Create time managed by system
  'lastLoginAt'   // Login time managed by system
])

type UserInputType = TypeOf<typeof UserInput>
// {
//   name: string
//   email: string
//   password: string
//   phone?: string
//   isAdmin: boolean
//   profile: { bio?: string, avatar?: string }
// }

// Create user update Schema (exclude non-modifiable fields)
const UserUpdate = omitObject(FullUser, [
  'id',
  'createdAt',
  'lastLoginAt',
  'password'      // Update password separately
])

// Use in API
app.post('/users', { body: UserInput }).use((req) => {
  const userData: UserInputType = req.body
  
  // Create user
  const newUser = createUser({
    ...userData,
    id: generateId(),
    createdAt: new Date(),
    lastLoginAt: null
  })
  
  // Return safe user info (without password)
  const safeUser: SafeUserType = omit(newUser, ['password'])
  
  return Response.status(201).json({ user: safeUser })
})

app.put('/users/<id:int>', { body: UserUpdate }).use((req) => {
  const userId = req.params.id
  const updateData: TypeOf<typeof UserUpdate> = req.body
  
  const updatedUser = updateUser(userId, updateData)
  
  // Return safe user info
  const safeUser: SafeUserType = omit(updatedUser, ['password'])
  
  return Response.json({ user: safeUser })
})
```

## Struct Field Operations

### pickStruct / omitStruct

For Schemas created using `Struct`, there are corresponding operations:

```typescript
import { Struct, pickStruct, omitStruct } from 'farrow-schema'

const FullUserStruct = Struct({
  id: Number,
  name: String,
  email: String,
  password: String,
  role: String,
  createdAt: Date
})

// Select public fields
const PublicUserStruct = pickStruct(FullUserStruct, ['id', 'name'])

// Exclude sensitive fields  
const SafeUserStruct = omitStruct(FullUserStruct, ['password'])

type PublicUserStructType = TypeOf<typeof PublicUserStruct>
// { id: number, name: string }

type SafeUserStructType = TypeOf<typeof SafeUserStruct>
// { id: number, name: string, email: string, role: string, createdAt: Date }

// Use in rapid prototyping
const createQuickAPI = (resource: string, schema: any) => {
  const publicSchema = omitStruct(schema, ['password', 'secret'])
  
  app.get(`/${resource}`).use(() => {
    const items = getAll(resource)
    return Response.json({ [resource]: items.map(item => pick(item, publicSchema)) })
  })
  
  app.get(`/${resource}/<id:int>`).use((req) => {
    const item = getById(resource, req.params.id)
    return Response.json({ [resource.slice(0, -1)]: pick(item, publicSchema) })
  })
}
```

## Field Optionality Operations

### partial - Convert to Optional Fields

`partial` converts all fields to optional fields, similar to TypeScript's `Partial<T>`:

```typescript
import { partial } from 'farrow-schema'

class User extends ObjectType {
  id = Number
  name = String
  email = String
  age = Number
}

// Create optional version
const PartialUser = partial(User)

type PartialUserType = TypeOf<typeof PartialUser>
// {
//   id?: number
//   name?: string  
//   email?: string
//   age?: number
// }

// Use in update operations
app.put('/users/<id:int>', { body: PartialUser }).use((req) => {
  const userId = req.params.id
  const updates: PartialUserType = req.body
  
  // Only update provided fields
  const updatedUser = updateUser(userId, updates)
  
  return Response.json({ user: updatedUser })
})

// Use in search filtering
app.get('/users/search', { 
  body: partial(pickObject(User, ['name', 'email'])) 
}).use((req) => {
  const filters: { name?: string, email?: string } = req.body
  
  const users = searchUsers(filters)
  
  return Response.json({ users })
})
```

### required - Convert to Required Fields

`required` is the opposite of `partial`, converting optional fields to required:

```typescript
import { required } from 'farrow-schema'

class OptionalUser extends ObjectType {
  id = Optional(Number)
  name = Optional(String)
  email = Optional(String)
}

// Convert to required
const RequiredUser = required(OptionalUser)

type RequiredUserType = TypeOf<typeof RequiredUser>
// {
//   id: number
//   name: string
//   email: string  
// }

// Use in validation steps
const validateCompleteUser = (data: any): RequiredUserType => {
  const result = Validator.validate(RequiredUser, data)
  
  if (result.isErr) {
    throw new Error(`Validation failed: ${result.value.message}`)
  }
  
  return result.value
}

// Multi-step form final validation
app.post('/users/complete-registration', { body: OptionalUser }).use((req) => {
  try {
    // Ensure all necessary fields are filled
    const completeUser = validateCompleteUser(req.body)
    
    const newUser = createUser(completeUser)
    
    return Response.status(201).json({ user: newUser })
  } catch (error) {
    return Response.status(400).json({ 
      error: 'Registration information incomplete',
      details: error.message 
    })
  }
})
```

## Complex Operations

### Chained Operations

You can combine multiple operations to create complex Schema transformations:

```typescript
class CompleteUser extends ObjectType {
  id = Number
  name = String
  email = String
  password = String
  phone = Optional(String)
  address = {
    street: String,
    city: String,
    zipCode: String
  }
  preferences = {
    theme: String,
    notifications: Boolean,
    language: String
  }
  createdAt = Date
  updatedAt = Optional(Date)
}

// Create user registration Schema
// 1. Exclude system fields
// 2. Make some fields optional
const UserRegistration = partial(
  omitObject(CompleteUser, [
    'id',
    'createdAt', 
    'updatedAt'
  ])
)

type UserRegistrationType = TypeOf<typeof UserRegistration>
// {
//   name?: string
//   email?: string
//   password?: string
//   phone?: string
//   address?: { street: string, city: string, zipCode: string }
//   preferences?: { theme: string, notifications: boolean, language: string }
// }

// Create user profile update Schema
// 1. Only select modifiable fields
// 2. Exclude password (update separately)
// 3. Make all fields optional
const UserProfileUpdate = partial(
  omitObject(
    pickObject(CompleteUser, [
      'name',
      'phone', 
      'address',
      'preferences'
    ]),
    []
  )
)

// Create admin user edit Schema
// 1. Exclude system fields and password
// 2. Keep other fields required
const AdminUserEdit = omitObject(CompleteUser, [
  'id',
  'password',
  'createdAt',
  'updatedAt'
])

// Use in different scenarios
app.post('/auth/register', { body: UserRegistration }).use(async (req) => {
  const registrationData: UserRegistrationType = req.body
  
  // Validate required fields
  if (!registrationData.name || !registrationData.email || !registrationData.password) {
    return Response.status(400).json({
      error: 'Name, email and password are required'
    })
  }
  
  const newUser = await createUser({
    ...registrationData,
    id: generateId(),
    createdAt: new Date()
  })
  
  return Response.status(201).json({ user: omit(newUser, ['password']) })
})

app.put('/profile', { body: UserProfileUpdate }).use((req) => {
  const currentUser = getCurrentUser(req)
  const updates: TypeOf<typeof UserProfileUpdate> = req.body
  
  const updatedUser = updateUser(currentUser.id, updates)
  
  return Response.json({ user: omit(updatedUser, ['password']) })
})
```

### Conditional Schema Transformations

```typescript
// Generate Schema dynamically based on user role
const createUserSchemaByRole = (role: 'admin' | 'user' | 'guest') => {
  const baseFields = ['name', 'email'] as const
  
  switch (role) {
    case 'admin':
      return pickObject(CompleteUser, [
        ...baseFields,
        'phone',
        'address', 
        'preferences',
        'createdAt',
        'updatedAt'
      ])
    
    case 'user':
      return pickObject(CompleteUser, [
        ...baseFields,
        'phone',
        'preferences'
      ])
    
    case 'guest':
      return pickObject(CompleteUser, baseFields)
  }
}

// Use in middleware
app.get('/users/<id:int>').use((req) => {
  const user = getUserById(req.params.id)
  const currentUser = getCurrentUser(req)
  
  // Return different information based on current user's role
  const userSchema = createUserSchemaByRole(currentUser.role)
  const filteredUser = pick(user, userSchema)
  
  return Response.json({ user: filteredUser })
})
```

## Schema Composition and Inheritance

### Using Intersect to Compose Schemas

```typescript
import { Intersect } from 'farrow-schema'

// Base information
class BaseInfo extends ObjectType {
  id = Number
  createdAt = Date
  updatedAt = Optional(Date)
}

// User information
class UserInfo extends ObjectType {
  name = String
  email = String
}

// Contact information
class ContactInfo extends ObjectType {
  phone = Optional(String)
  address = Optional(String)
}

// Compose into complete user
const FullUser = Intersect(BaseInfo, UserInfo, ContactInfo)

type FullUserType = TypeOf<typeof FullUser>
// {
//   id: number
//   createdAt: Date
//   updatedAt?: Date
//   name: string
//   email: string
//   phone?: string
//   address?: string
// }

// Create different combinations
const PublicUser = Intersect(
  pickObject(BaseInfo, ['id']),
  UserInfo
)

const UserWithContact = Intersect(UserInfo, ContactInfo)

// Use in API
app.get('/users/<id:int>/full').use((req) => {
  const user = getUserById(req.params.id)
  const fullUser: FullUserType = user
  
  return Response.json({ user: fullUser })
})

app.get('/users/<id:int>/public').use((req) => {
  const user = getUserById(req.params.id)
  const publicUser: TypeOf<typeof PublicUser> = {
    id: user.id,
    name: user.name,
    email: user.email
  }
  
  return Response.json({ user: publicUser })
})
```

## Summary

By mastering these Schema operation techniques, you can:

- 🎯 **Extract Precise Types** - Use `TypeOf` to get complete type safety
- 🔧 **Flexibly Select Fields** - Use `pick` and `omit` to create different Schema views
- 📝 **Adjust Field Requirements** - Use `partial` and `required` to change field optionality
- 🔄 **Compose Multiple Schemas** - Use `Intersect` and chained operations to build complex structures
- 🏗️ **Build Reusable Systems** - Improve development efficiency through chained operations and composition

::: tip 💡 Best Practices
- Create named constants for commonly used Schema variants
- Use type aliases to improve code readability
- Document different fields returned by different endpoints in API documentation
- Consider backward compatibility, especially during API upgrades
:::

## Next Steps

After mastering Schema operations, you can continue learning:

**[Pipeline Core Concepts](./pipeline-concepts)**  
Understand Pipeline, usePipeline, and Container management in depth